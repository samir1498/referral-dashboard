# Setup & prereqs

1. Make sure you have these installed:

   * Node (v18+ recommended)
   * pnpm (`npm i -g pnpm`)
   * PostgreSQL (local or a cloud DB like Supabase/Neon)
   * Git
   * VS Code or your editor of choice

2. Create project repo and initial Next app:

```bash
pnpm create next-app@latest referral-dashboard -- --typescript --eslint --app
cd referral-dashboard
git init
```

## Project skeleton (commands)

Run these to scaffold the stack:

```bash
# Tailwind
pnpm add -D tailwindcss postcss autoprefixer
pnpm exec tailwindcss init -p

# shadcn UI helper (optional but recommended)
pnpm dlx shadcn-ui@latest init
pnpm dlx shadcn-ui@latest add button card table sidebar navbar

# other UI / chart libs
pnpm add react-icons recharts clsx

# Drizzle + Postgres driver + dotenv
pnpm add drizzle-orm pg dotenv

# Drizzle migrations + dev helpers
pnpm add -D drizzle-kit tsx @types/pg

# Tests
pnpm add -D vitest @testing-library/react @testing-library/user-event jsdom
pnpm add -D @playwright/test
pnpm dlx playwright install
```

## Project layout & naming (follow these files)

Create/use the following structure and file names. Keep names exactly as below for consistency.

```plain
src/
  domain/
    entities/Referral.ts
    value-objects/Email.ts
    value-objects/ReferralStatus.ts
    repositories/IReferralRepository.ts
    services/ReferralService.ts

  application/
    use-cases/AddReferralUseCase.ts
    use-cases/ListReferralsUseCase.ts

  infrastructure/
    db/connection.ts
    db/schema.ts
    repositories/ReferralRepositoryDrizzle.ts

app/
  api/
    referrals/route.ts
  dashboard/
    layout.tsx
    overview/page.tsx
    referrals/page.tsx
    testimonials/page.tsx
src/interface/ui/components/
  Sidebar.tsx
  Navbar.tsx
  ReferralTable.tsx
  TestimonialCard.tsx

lib/
  fakeData.ts       # optional for prototyping without DB
drizzle.config.ts
drizzle/migrations/   # generated by drizzle-kit
tests/
  unit/
  e2e/
```

## Step-by-step implementation

---

## 1) Tailwind + shadcn basic setup

1. Configure `tailwind.config.cjs` content paths to include `app/`, `src/`, `components/`:

```js
module.exports = {
  content: ["./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}"],
  theme: { extend: {} },
  plugins: []
}
```

2. Add Tailwind imports to `app/globals.css`:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

3. Run dev and confirm `http://localhost:3000` loads:

```bash
pnpm dev
```

---

## 2) Domain layer (pure TS, no framework imports)

Create domain models/value objects and repository interfaces.

**`src/domain/value-objects/Email.ts`**

```ts
export class Email {
  private readonly value: string;
  constructor(value: string) {
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) throw new Error("Invalid email");
    this.value = value;
  }
  toString() { return this.value; }
}
```

**`src/domain/value-objects/ReferralStatus.ts`**

```ts
export enum ReferralStatus {
  Pending = "Pending",
  Converted = "Converted",
}
```

**`src/domain/entities/Referral.ts`**

```ts
import { Email } from "../value-objects/Email";
import { ReferralStatus } from "../value-objects/ReferralStatus";

export class Referral {
  constructor(
    public id: string,
    public name: string,
    public email: Email,
    public date: Date,
    public status: ReferralStatus = ReferralStatus.Pending
  ) {}
  convert() { this.status = ReferralStatus.Converted; }
}
```

**`src/domain/repositories/IReferralRepository.ts`**

```ts
import { Referral } from "../entities/Referral";

export interface IReferralRepository {
  save(referral: Referral): Promise<void>;
  findAll(): Promise<Referral[]>;
  findById(id: string): Promise<Referral | null>;
}
```

> Implement domain tests later (unit tests target these pure classes).

---

## 3) Application layer: use-cases

**`src/application/use-cases/AddReferralUseCase.ts`**

```ts
import { IReferralRepository } from "@/domain/repositories/IReferralRepository";
import { Referral } from "@/domain/entities/Referral";
import { Email } from "@/domain/value-objects/Email";

export class AddReferralUseCase {
  constructor(private repo: IReferralRepository) {}
  async execute(input: { name: string; email: string }) {
    const referral = new Referral(crypto.randomUUID(), input.name, new Email(input.email), new Date());
    await this.repo.save(referral);
    return referral;
  }
}
```

**`src/application/use-cases/ListReferralsUseCase.ts`**

```ts
import { IReferralRepository } from "@/domain/repositories/IReferralRepository";

export class ListReferralsUseCase {
  constructor(private repo: IReferralRepository) {}
  async execute() {
    return this.repo.findAll();
  }
}
```

---

## 4) Infrastructure: Drizzle setup & schema

1. Create `.env` (gitignored):

```
DATABASE_URL=postgresql://user:pass@localhost:5432/referraldb
DRIZZLE_MIGRATIONS=./drizzle/migrations
```

2. Drizzle connection **`src/infrastructure/db/connection.ts`**

```ts
import 'dotenv/config';
import pg from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';

const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool);
```

3. Drizzle schema **`src/infrastructure/db/schema.ts`**

```ts
import { pgTable, serial, varchar, timestamp, pgEnum, text } from 'drizzle-orm/pg-core';

export const referralStatus = pgEnum('referral_status', ['Pending', 'Converted']);

export const referrals = pgTable('referrals', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  email: varchar('email', { length: 255 }).notNull(),
  date: timestamp('date').defaultNow().notNull(),
  status: referralStatus.default('Pending').notNull()
});

export const testimonials = pgTable('testimonials', {
  id: serial('id').primaryKey(),
  quote: text('quote').notNull(),
  author: varchar('author', { length: 255 }).notNull(),
  company: varchar('company', { length: 255 })
});
```

4. `drizzle.config.ts` at repo root:

```ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  schema: './src/infrastructure/db/schema.ts',
  out: './drizzle/migrations',
  driver: 'pg'
});
```

5. Generate & apply migrations:

```bash
pnpm dlx drizzle-kit generate --name init
pnpm dlx drizzle-kit migrate
```

(If you get errors, check `DATABASE_URL` and Postgres availability.)

---

## 5) Infrastructure: repository implementation

**`src/infrastructure/repositories/ReferralRepositoryDrizzle.ts`**

```ts
import { IReferralRepository } from "@/domain/repositories/IReferralRepository";
import { Referral } from "@/domain/entities/Referral";
import { Email } from "@/domain/value-objects/Email";
import { db } from "../db/connection";
import { referrals } from "../db/schema";

export class ReferralRepositoryDrizzle implements IReferralRepository {
  async save(referral: Referral) {
    await db.insert(referrals).values({
      name: referral.name,
      email: referral.email.toString(),
      date: referral.date,
      status: referral.status
    });
  }
  async findAll(): Promise<Referral[]> {
    const rows = await db.select().from(referrals).orderBy(referrals.date.desc);
    return rows.map(r =>
      new Referral(String(r.id), r.name, new Email(r.email), new Date(r.date), r.status)
    );
  }
  async findById(id: string) {
    const row = await db.select().from(referrals).where(referrals.id.eq(Number(id))).then(res => res[0]);
    if (!row) return null;
    return new Referral(String(row.id), row.name, new Email(row.email), new Date(row.date), row.status);
  }
}
```

> Note: `referrals.id` is serial (number). Convert between numeric DB id and string domain id if desired. You can switch to `uuid` if you prefer.

---

## 6) Interface layer: API routes (App Router)

**`app/api/referrals/route.ts`**

```ts
import { NextResponse } from "next/server";
import { ReferralRepositoryDrizzle } from "@/infrastructure/repositories/ReferralRepositoryDrizzle";
import { AddReferralUseCase } from "@/application/use-cases/AddReferralUseCase";
import { ListReferralsUseCase } from "@/application/use-cases/ListReferralsUseCase";

const repo = new ReferralRepositoryDrizzle();

export async function GET() {
  const useCase = new ListReferralsUseCase(repo);
  const data = await useCase.execute();
  return NextResponse.json(data);
}

export async function POST(req: Request) {
  const body = await req.json();
  if (!body.name || !body.email) return NextResponse.json({ error: "name & email required" }, { status: 400 });
  const useCase = new AddReferralUseCase(repo);
  const referral = await useCase.execute({ name: body.name, email: body.email });
  return NextResponse.json(referral, { status: 201 });
}
```

---

## 7) Interface layer: Dashboard pages & components

* Implement `app/dashboard/layout.tsx` with server component that wraps `Sidebar` and `Navbar`.
* Use server components (default in App Router) to fetch server-side data when possible.
* Use client components for interactive UI (forms, modals).

**`src/interface/ui/components/ReferralTable.tsx`** (client component skeleton)

```tsx
"use client";
import React from "react";
type Props = { items: { id: string; name: string; email: string; date: string; status: string }[] };
export default function ReferralTable({ items }: Props) {
  return (
    <table className="w-full">
      <thead><tr><th>Name</th><th>Email</th><th>Date</th><th>Status</th></tr></thead>
      <tbody>
        {items.map(i => <tr key={i.id}><td>{i.name}</td><td>{i.email}</td><td>{i.date}</td><td>{i.status}</td></tr>)}
      </tbody>
    </table>
  );
}
```

**`app/dashboard/referrals/page.tsx`** (server side)

```tsx
import { ReferralRepositoryDrizzle } from "@/infrastructure/repositories/ReferralRepositoryDrizzle";
import ReferralTable from "@/interface/ui/components/ReferralTable";

export default async function ReferralsPage() {
  const repo = new ReferralRepositoryDrizzle();
  const referrals = await repo.findAll();
  const items = referrals.map(r => ({ id: r.id, name: r.name, email: r.email.toString(), date: r.date.toISOString(), status: r.status }));
  return <div><h1>Referrals</h1><ReferralTable items={items} /></div>
}
```

---

## 8) Add a simple demo auth page (optional)

For demo purpose, `app/auth/page.tsx` with a "Login as Demo" button that sets a cookie or client state and redirects to `/dashboard`. This avoids needing full auth for MVP.

---

## 9) Tests

### Vitest (unit)

1. `vitest.config.ts`:

```ts
import { defineConfig } from "vitest/config";
export default defineConfig({
  test: { environment: "jsdom", globals: true, setupFiles: "./tests/setup.ts" }
});
```

2. `tests/setup.ts`:

```ts
import "@testing-library/jest-dom";
```

3. Example unit test `tests/unit/Referral.test.ts`:

```ts
import { Referral } from "@/domain/entities/Referral";
import { Email } from "@/domain/value-objects/Email";
import { ReferralStatus } from "@/domain/value-objects/ReferralStatus";

test("Referral conversion", () => {
  const r = new Referral("1","Alice", new Email("a@a.com"), new Date(), ReferralStatus.Pending);
  r.convert();
  expect(r.status).toBe(ReferralStatus.Converted);
});
```

Run unit tests:

```bash
pnpm test
```

### Playwright (E2E)

1. Create `tests/e2e/referral.spec.ts` with flow:

   * Visit `/auth`, click demo login.
   * Go to `/dashboard/referrals`, click Add, fill form, create, see new row.
2. Run Playwright:

```bash
pnpm dlx playwright test
```

---

## 10) CI (GitHub Actions) — minimal `/.github/workflows/ci.yml`

```yaml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v2
        with: { version: 8 }
      - run: pnpm install
      - run: pnpm lint
      - run: pnpm test
      - run: pnpm build
      - run: pnpm start &   # start server to run playwright
      - run: pnpm dlx playwright install --with-deps
      - run: pnpm test:e2e
```

> In CI, if you use a real DB, run `drizzle-kit migrate` before tests using a `DATABASE_URL` secret.

---

## 11) Deploy to Vercel

* Push to GitHub.
* Connect GitHub repo in Vercel dashboard.
* Set Vercel project to use `pnpm` (Vercel detects automatically if pnpm lockfile exists).
* Add `DATABASE_URL` as environment variable.
* Ensure migrations run before or during deploy (you can run migrations in CI or include a Vercel prebuild command to run `pnpm dlx drizzle-kit migrate`).

---

## 12) Hardening & production notes (short checklist)

* Validate inputs on server (use `zod` for request body validation).
* Sanitize text rendered from testimonials.
* Add rate limiting / basic abuse protection on POSTs.
* Add DB connection pooling and watch for too-many-connections in serverless environments (use a pool and persist it across modules).
* Add auth & tenant handling before making it public.

---

## Debugging tips (common gotchas)

* *Cannot connect to DB*: check `DATABASE_URL`, Postgres running, firewall, credentials.
* *Drizzle migration issues*: ensure `drizzle.config.ts` path points to `schema.ts`, delete older migrations only when safe.
* *Playwright flakiness*: ensure dev server started and seeded DB before tests run; use `page.waitForSelector()` where necessary.
* *pnpm + native modules errors*: run `pnpm install` fresh, sometimes removing `node_modules` + `pnpm store prune` helps.

---

## Minimal `package.json` scripts (add to package.json)

```json
"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "next lint",
  "test": "vitest",
  "test:unit": "vitest",
  "test:e2e": "playwright test",
  "migrate": "pnpm dlx drizzle-kit migrate"
}
```

---

## Quick checklist (tick as you go)

* [ ] `pnpm create next-app` + confirm dev server works
* [ ] Tailwind + shadcn working, basic UI component renders
* [ ] Domain models and interfaces implemented
* [ ] Drizzle schema + connection created
* [ ] `drizzle-kit generate` and `drizzle-kit migrate` succeed
* [ ] ReferralRepositoryDrizzle implemented and tested in REPL
* [ ] API routes wired to use-cases
* [ ] Dashboard layout + referrals page shows data from DB
* [ ] Unit tests pass (`pnpm test`)
* [ ] Playwright E2E runs locally
* [ ] CI workflow added
* [ ] Repo connected & deployed on Vercel

---

## Final tips for working solo

* Implement in small, testable steps. After finishing a step, run the app and test manually.
* Keep domain code framework-free — that makes unit testing and reasoning easier.
* If you’re tired or stuck, stop after a small step and push what’s working — incremental progress > big rewrites.
* If you want, I can generate specific file contents one-by-one (e.g., `connection.ts`, `schema.ts`, `route.ts`) for you to copy/paste. Tell me **which file** you want first and I’ll output the full file content.
